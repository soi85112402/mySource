<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="./PointerLockControls.js" type="module"></script>
    <style>
*{margin: 0;padding: 0;}

    </style>
</head>
<body>
    
    <script>
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

//Chao
var geometry = new THREE.BoxGeometry( 100, 1, 100 );
var material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
var chao = new THREE.Mesh( geometry, material );
scene.add( chao );
chao.receiveShadow = true;

// Cubo1
var geometry = new THREE.BoxGeometry( 1, 1, .1 );
var material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
var cube = new THREE.Mesh( geometry, material );
scene.add( cube );
cube.position.y = 2;
cube.castShadow = true;

var ambientLight = new THREE.AmbientLight(0xffffff,0.5);
scene.add(ambientLight);
var spotLight = new THREE.SpotLight(0xffffff);
spotLight.position.set(0, 20, 8);
spotLight.castShadow = true;
scene.add(spotLight);

camera.position.x = 0;
camera.position.y = 2;
camera.position.z = 5;

window.addEventListener('deviceorientation', function(e) {
    cube.rotation.x = e.alpha/100;
    cube.rotation.y = e.beta/100;
    cube.rotation.z = e.gamma/100;
});

var x, y;
var pressed=false;
var enabled =true;

window.addEventListener( 'mousedown', onTouchStart );
window.addEventListener( 'touchstart', onTouchStart );
function onTouchStart( event ) {
	if ( event.changedTouches ) {
		x = event.changedTouches[ 0 ].pageX;
		y = event.changedTouches[ 0 ].pageY;
	} else {
		x = event.clientX;
		y = event.clientY;
	}
    pressed=true;
}

window.addEventListener( 'mouseup', onTouchEnd );
window.addEventListener( 'touchend', onTouchEnd );
window.addEventListener("keydown", onDocumentKeyDown, false);
window.addEventListener("keyup", onDocumentKeyUp, false);

function onTouchEnd( event ) {
    pressed=false;
}

var xSpeed = 1;
var ySpeed = 1;

let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let canJump = false;

function onDocumentKeyDown(event) {
    
    var keyCode = event.which;
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = true;
            break;
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = true;
            break;
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = true;
            break;
        case 'ArrowRight':
        case 'KeyD':
            moveRight = true;
            break;

        case 'Space':
            if ( canJump === true ) velocity.y += 350;
            canJump = false;
            break;
        // case 87 : // 전진
        //     camera.position.z -= ySpeed;

        //     break;
        // case 83 : // 후진
        //     camera.position.z += ySpeed;

        //     break;
        // case 65 : // 좌 전진
        //     camera.position.x -= xSpeed;

        //     break;
        // case 68 : // 우 전진
        //     camera.position.x += xSpeed;

        //     break;
        // case 37 : // turn left
        //     camera.position.z += ySpeed;

        //     break;
        // case 39 : // turn right
        //     camera.position.z += ySpeed;

        //     break;
        // case 38 : // upon
        //     camera.position.z += ySpeed;

        //     break;
        // case 40 : // down
        //     camera.position.z += ySpeed;

        //     break;
    }

    // console.log(`keyCode ${keyCode}`);
    // console.log(camera.position.x);

    // updateCamera(a);
};


function onDocumentKeyUp(event) {

    switch ( event.code ) {
    
    case 'ArrowUp':
    case 'KeyW':
        moveForward = false;
        break;
    
    case 'ArrowLeft':
    case 'KeyA':
        moveLeft = false;
        break;
    
    case 'ArrowDown':
    case 'KeyS':
        moveBackward = false;
        break;
    
    case 'ArrowRight':
    case 'KeyD':
        moveRight = false;
        break;
    
    }
}

// new TWEEN.Tween(camera.rotation)
//     .to(
//       {
//         x: endRotation.x,
//         y: endRotation.y,
//         z: endRotation.z,
//       }, 500)
//     .easing(TWEEN.Easing.Quadratic.InOut)
//     .onComplete(() => {
//       new TWEEN.Tween(camera.position)
//         .to({
//           x: marker.cameraPositionX,
//           y: camera.position.y,
//           z: marker.cameraPositionZ,
//         })
//         .easing(TWEEN.Easing.Quadratic.InOut)
//         .onUpdate(() => {
//           camera.lookAt(storedMarkerPosition);
//         })
//         .onComplete(() => {
//           camera.lookAt(storedMarkerPosition);
//           radius = Math.hypot(...Object.values(markerPosition));
//           phi = Math.acos(markerPosition.y / radius);
//           theta = Math.atan2(markerPosition.z, markerPosition.x);
//           lon = THREE.Math.radToDeg(theta);
//           lat = 90 - THREE.Math.radToDeg(phi);
//         })
//         .start();
//     })
//     .start();

function updateCamera() {
    console.log(camera.position.x,camera.position.y,camera.position.z);
    
    camera.lookAt(camera.position.x,camera.position.y,camera.position.z);
    camera.updateProjectionMatrix();
}
		
var render = function() {
    requestAnimationFrame(render);
    // cube.rotation.x += 0.03;
    // cube.rotation.y += 0.02;
    // cube.rotation.z += 0.01;
    renderer.render(scene, camera);
};

var animate = function () {
	requestAnimationFrame( animate );

    if(pressed){
        if(x<window.innerWidth/2){	
            camera.rotation.y += 0.02;
        }else{
            camera.rotation.y -= 0.02;	
        }
    }	
	
	renderer.render(scene, camera);
};

animate();
    </script>
</body>
</html>